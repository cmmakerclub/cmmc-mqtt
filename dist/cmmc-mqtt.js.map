{"version":3,"sources":["cmmc-mqtt.js"],"names":["create","mqttOpts","subTopics","autoconnect","_opts","clone","_connectString","username","password","host","port","_forwardClient","_forwardPrefix","_mqtt","connect","_callbacks","on_connected","on_connecting","on_message","topic","payload","on_close","on_error","on_packetsend","packet","cmd","verbose","JSON","stringify","subscriptions","ret","call","on","publish","forEach","idx","subscribe","register","cbName","func","forward","mqttClient","options","prefix","debug"],"mappings":"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","file":"cmmc-mqtt.js","sourcesContent":["import { logger } from './utils'\nimport _ from 'underscore'\nimport mqtt from 'mqtt'\n\nexport default {\n  create: (mqttOpts, subTopics = [], autoconnect = true) => {\n    const _opts = _.clone(mqttOpts)\n    let _connectString\n    if (_opts.username && _opts.password) {\n      _connectString = `${_opts.host}:${_opts.password}@${_opts.host}`\n    } else {\n      _connectString = `${_opts.host}:${_opts.port}`\n    }\n    let _forwardClient, _forwardPrefix\n    const _mqtt = mqtt.connect(_connectString)\n    const _callbacks = {\n      on_connected: () => { },\n      on_connecting: () => { },\n      on_message: (topic, payload) => { },\n      on_close: () => { },\n      on_error: () => { },\n      on_packetsend: (packet) => {\n        if (packet.cmd === 'subscribe') {\n          logger.verbose(`subscribing to topic = ${JSON.stringify(packet.subscriptions)}`)\n        } else {\n          logger.verbose(`cmd = ${packet.cmd}, packet = ${JSON.stringify(packet)}`)\n        }\n      }\n    }\n    const ret = {\n      connect: () => {\n        _callbacks.on_connecting.call(this)\n        // register callbacks\n        _mqtt.on('packetsend', _callbacks.on_packetsend)\n        _mqtt.on('message', (topic, payload) => {\n          _callbacks.on_message(topic, payload)\n          if (_forwardClient) {\n            _forwardClient.publish(`${_forwardPrefix}${topic}`, payload)\n          }\n        })\n        _mqtt.on('close', _callbacks.on_close)\n        _mqtt.on('error', _callbacks.on_error)\n        _mqtt.on('connect', () => {\n          _callbacks.on_connected.call(this)\n          subTopics.forEach((topic, idx) => _mqtt.subscribe(topic))\n        })\n      },\n      register: (cbName, func) => {\n        if (_callbacks[cbName]) {\n          logger.verbose(`register callback ${cbName}`)\n          _callbacks[cbName] = func\n        } else {\n          logger.verbose(`try to register unlisted callback = ${cbName}`)\n        }\n      },\n      forward: (mqttClient, options) => {\n        options.prefix = options.prefix || ''\n        logger.debug(`prefix = ${options.prefix}`)\n        _forwardClient = mqttClient\n        _forwardPrefix = options.prefix\n      },\n      publish: (topic, payload) => {\n        _mqtt.publish(topic, payload)\n      }\n    }\n\n    if (autoconnect) {\n      ret.connect()\n    }\n    return ret\n  }\n}\n"],"sourceRoot":"/Users/nat/projects/traffy/master-slave-v2/easy-mqtt/dist"}